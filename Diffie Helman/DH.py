# Modular Exponentiation function
def mod_exp(x, y, N):
    if y is 0:
        return 1
    z = mod_exp(x, y//2, N)
    if y % 2 is 0:
        return (z**2) % N
    else:
        return x * (z**2) % N


# Generated with int(os.urandom(63).hex(), 16)
a = 15547755883311764520038259838080628438707284224742596537592010696589479024011195016483078724054919575190498026716885207746921135836422089208496995027683
# Generated with openssl prime -hex -generate -bits 500 -safe
p = 0x0D3477A7823A2F0781637A2E0430117E6B962CACADC3BF40600EA510898FBEC668082B5857FCF8163CAAA6DAEE684B5C3E229134DE1B1D26F8671D1AF00487
g = 5

gModPB = 1200144630821827109693857059445357910303833436457022354114584817924604029979961095163811148978887569708379798687988181845963602442791042007315800398573
gModPA = mod_exp(g, a, p)

print(a)
print(p)
print(gModPA)
gABMine = mod_exp(gModPB, a, p)
print(gABMine)
